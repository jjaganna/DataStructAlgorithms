{\rtf1\ansi\ansicpg1252\cocoartf2639
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
\margl1440\margr1440\vieww11520\viewh18280\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0\fs24 \cf0 Sorted Squared Array (Easy)\
\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\
Write a function that takes in a non-empty array of integers that are sorted in ascending order and returns a new array of the same length with squares of the original integers also sorted in ascending order.\
\
Sample Input:\
Array = [1,2,3,5,6,8,9]\
\
Sample Output:\
[1,4,9, 25, 36, 64, 81]\
\
\
Hints:\
\
Hint1: While integers in the input array are in sorted in increasing order, their squares won\'92 necessarily be as well, because of the possible presence of negative numbers.\
\
Hint2: Traverse the array value by value, square each value, and insert the squares into an output array. Then, sort the output array before returning it. Is this the optimal solution?\
\
Hint3: To reduce the time complexity of the algorithm mentioned in Hint#2, you need to avoid sorting the output array. To do this, as you square the values of the input array, try to directly insert them into their corresponding position in the output array.\
\
Hint4: Use 2 pointers to keep track of the smallest and the largest values in the input array. Compare the absolute value of the smallest and the largest values, square the larger absolute value, and place the square at the end of the output array, filling it from right to left. Move the pointers accordingly and repeat this process until the output array is filled.\
\
\
Optimal Space and Time complexity \
\
O(n) time | O(n) space \'97 where n is the length of the input array\
\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\
Solution 1:  O(n log(n)) time | O(n) space. - Using Hint#1 Brute Force solution.\
\
def sortedSquaredArray(array):\
    res_array = []\
    for num in array:\
        res_array.append(num**2)\
    return sorted(res_array)\
\
\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\
Solution 2 :  O(n) time | O(n) space. \'97 Best Solution.\
\
def sortedSquaredArray(array):\
    left = 0\
    right = len(array) - 1\
    res_array = []\
    while (left <= right):\
        if abs(array[left]) > abs(array[right]):\
            res_array.append((array[left])**2)\
            left += 1\
        else: \
            res_array.append((array[right])**2)\
            right -= 1\
    return res_array[::-1]\
\
\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\
\
Solution 3:  O(n log(n) time | O(n) space\
\
def sortedSquaredArray(array):\
    return sorted([num*num for num in array])\
\
\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\'97\
\
Solution 4: O(n) time | O(n) space. \'97 Best Solution. (Similar to Solution #2).\
# We populate the result array res_array from end to the beginning (I.e. largest to smallest).\
\
def sortedSquaredArray(array):\
    left = 0\
    right = len(array) - 1\
    res_array = [0 for _ in array]\
    idx = len(array) - 1   # index for the result array initialized\
    while (left <= right):\
        if abs(array[left]) > abs(array[right]):\
            res_array[idx] = array[left]**2\
            left += 1\
        else: \
            res_array[idx] = array[right]**2\
            right -= 1\
        idx -= 1\
    return res_array\
\
===============================================\
\
Algoexpert Solutions\
\
\
Solution 1:  O(n log(n)) time | O(n) space\
\
def sortedSquaredArray(array):\
      sortedSquares = [0 for _ in array]\
  \
\
       for idx in range(len(array)):\
            value = array[idx]\
            sortedSquares[idx] = value * value\
      \
       sortedSquares.sort()\
\
       return sortedSquares\
\
\
===================\
\
Solution 2:  O(n) time | O(n) space \'97 Best Solution\
\
\
def sortedSquaredArray(array):\
      sortedSquares = [0 for _ in array]\
\
       smallerValueIdx = 0\
       largerValueIdx = len(array) - 1\
\
       for idx in reversed(range(len(array))):\
       #for idx in range(largerValueIdx, -1, -1):\
  \
            smallerValue = array[smallerValueIdx]\
            largerValue = array[largerValueIdx]\
           \
            if abs(smallerValue) > abs(largerValue):\
                  sortedSquares[idx] = smallerValue * smallerValue\
                  smallerValueIdx += 1\
            else:\
                  sortedSquares[idx] = largerValue * largerValue\
                  largerValueIdx  -=1\
          \
         return sortedSquares\
\
\
}